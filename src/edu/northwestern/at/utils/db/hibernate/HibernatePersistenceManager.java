package edu.northwestern.at.utils.db.hibernate;

/*	Please see the license information at the end of this file. */

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.hibernate.HibernateException;
import org.hibernate.MappingException;
import org.hibernate.ScrollableResults;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.query.Query;

import edu.northwestern.at.utils.db.PersistenceException;

/**	A Hibernate persistence manager.
 *
 *	<p>This class encapsulates all of the base calls to the Hibernate persistence
 *	API.
 *	</p>
 *
 *	<p>
 *	The static {@link #init init} method must be called to initialize
 *	Hibernate before using the constructor to create any HibernatePersistenceManager
 *	objects.
 *	</p>
 *
 *	<p>
 *	Each persistence manager has its own Hibernate session. Hibernate
 *	sessions are not thread safe, so separate threads should use separate
 *	persistence managers.
 *	</p>
 *
 *	<p>
 *	The {@link #begin begin}, {@link #commit commit}, and
 *	{@link #rollback rollback} methods are used for transactions.
 *	Object creation, deletion, and
 *	mutation should be done inside transactions. For object use without mutation
 *	(plain old Java object graph navigation), it is not necessary to use
 *	transactions, or any of the other methods of this class.
 *	</p>
 *
 *	<p>
 *	The {@link #save save} and {@link #delete delete} methods are used to
 *	save newly constructed objects and collections of objects (make them
 *	persistent) and to delete objects and collections of objects (rendering
 *	the copies of the objects in memory transient or non-persistent).  Static
 *	convenience forms of the methods are called {@link #doSave doSave} and
 *	{@link #doDelete doDelete}.
 *	</p>
 *
 *	<p>
 *	The {@link #load load} method fetches a persistent object given its "handle"
 *	(Java class and unique id).  This may be a proxy object.
 *	</p>
 *
 *	<p>
 *	The {@link #get get} method fetches a persistent object given its "handle"
 *	(Java class and unique id).  A get nominally never returns a proxy object,
 *	but we have observed that they do.  Hence there appears to be no reliable
 *	method of converting a proxy object to a real object.
 *	</p>
 *
 *	<p>
 *	The {@link #refresh refresh} method refreshes a persistent object
 *	ignoring any copies in the cache.
 *	</p>
 *
 *	<p>
 *	The {@link #contains contains} method checks if an object has been
 *	checked out in the context of the current thread's persistence manager.
 *	The corresponding static convenience method is
 *	{@link #doContains doContains} .
 *	</p>
 *
 *	<p>
 *	The {@link #clear clear} method clears the Hibernate first-level cache.
 *	The {@link #evict evict} methods clear the Hibernate second-level cache.
 *	</p>
 *
 *	<p>
 *	Several variants of the {@link #query query} method provide for running
 *	queries and retrieving results in a list.  There are also static
 *	{@link #doQuery doQuery}
 *	methods for performing queries using the persistence manager for the
 *	current thread.  The {@link #countQuery countQuery} methods provide for
 *	retrieving an integer count as the result of a query.
 *	</p>
 *
 *	<p>
 *	A thread-local variable holds the persistence manager for
 *	each thread, whicb is created as needed when doQuery is called.  The
 *	static {@link #closePM closePM} method should be called at the end
 *	of the thread to close the persistence manager.
 *	</p>
 *
 *	<p>
 *	Most exceptions thrown by Hibernate are wrapped in our own
 *	{@link edu.northwestern.at.utils.db.PersistenceException}
 *	exceptions and rethrown. Some of the
 *	static convenience methods absorb Hibernate exceptions and pass back
 *	null values or boolean values representing the success or failure
 *	of the persistence operation.
 *	</p>
 */

public class HibernatePersistenceManager
{
	/**	The Hibernate session factory.
	 *
	 *	<p>Note that this field is static - there is only one session factory
	 *	for the entire program.
	 */

	protected static SessionFactory sessionFactory;

	/**	The Hibernate session.
	 *
	 *	<p>Note that this field is not static - each HibernatePersistenceManager
	 *	has its own private Hibernate session, generated by the factory
	 *	when the persistence manager is constructed.
	 */

	protected Session session;

	/**	The current Hibernate transaction, or null if there is no
	 *	transaction currently in progress.
	 */

	protected Transaction t;

	/**	The thread-based persistence manager.
	 */

	protected static final ThreadLocal threadPM	= new ThreadLocal();

	/**	True to enable stack trace output for static persistence methods.
	 */

	protected static boolean stackTracesEnabled	= false;

	/**	JDBC batch size. */

	public static final int JDBC_BATCH_SIZE = 50;

	/**	Initializes Hibernate.
	 *
	 *	@param	url					URL for MySQL database, or null to use the
	 *								"hibernate.properties" or
	 *								"hibernate.cfg.xml" for setting
	 *								the Hibernate parameters.
	 *
	 *	@param	username			Username for MySQL database access. Ignored
	 *								if url = null.
	 *
	 *	@param	password			Password for MySQL database access. Ignored
	 *								if url = null.
	 *
	 *	@param	configFilePath		The full path to the configuration file.
	 *								May be either a properties file or an
	 *								xml file.  Ignored if null.
	 *
	 *	@param	persistentClasses	Array of persistent classes.  Should not be
	 *								null.
	 *
	 *	@param	cache2				true to use second level cache.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public static void init
	(
		String url ,
		String username ,
		String password ,
		String configFilePath ,
		Class[] persistentClasses ,
		boolean cache2
	)
		throws PersistenceException
	{
		try
		{
								//	Create a Hibernate configuration object.

			Configuration cfg	= new Configuration();

								//	If the database URL is specified,
								//	set the properties from the url,
								//	username, and password entries.  If
								//	url is null, the external hibernate
								//	configuration file will be used instead.

			if ( url != null )
			{
				cfg.setProperty(
					"hibernate.dialect edu.northwestern.at.utils.db.mysql.WordHoardMySQLDialect" ,
					"1" );

				cfg.setProperty(
					"hibernate.connection.driver_class" ,
					"com.mysql.cj.jdbc.Driver" );

				cfg.setProperty(
					"hibernate.connection.url" , url );

				cfg.setProperty(
					"hibernate.connection.username" , username );

				cfg.setProperty(
					"hibernate.connection.password" , password );
			}
								//	Set JDBC batch size.
			cfg.setProperty(
				"hibernate.jdbc.batch_size" ,
				Integer.toString( JDBC_BATCH_SIZE ) );

								//	Enable or disable use of
								//	second level cache.
			cfg.setProperty(
				"hibernate.cache.use_second_level_cache" ,
				cache2 ? "true" : "false" );

								//	Add the persistent classes to the
								//	configuration.

			if ( persistentClasses != null )
			{
				for ( int i = 0 ; i < persistentClasses.length ; i++ )
				{
					cfg.addClass( persistentClasses[ i ] );
				}
			}
								//	Set location of configuration file
								//	if provided.

			if ( configFilePath != null )
			{
//				cfg.configure( configFilePath );
			}
								//	Obtain a session factory.  All
								//	access to persistent objects must occur
								//	in the context of a session, which we
								//	obtain from this session factory as
								//	needed.

			sessionFactory = cfg.buildSessionFactory();
		}
		catch ( MappingException e )
		{
			throw new PersistenceException( e );
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Initializes Hibernate using the "hibernate.properties" file.
	 *
	 *	@param	configFilePath		The full path to the configuration file.
	 *								May be either a properties file or an
	 *								xml file.  Ignored if null.
	 *
	 *	@param	persistentClasses	Array of persistent classes.  Should not be
	 *								null.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public static void init
	(
		String configFilePath ,
		Class[] persistentClasses
	)
		throws PersistenceException
	{
		init( null , null , null , configFilePath , persistentClasses , false );
	}

	/**	Initializes Hibernate using the default configuration file.
	 *
	 *	@param	persistentClasses	Array of persistent classes.  Should not be
	 *								null.
	 *
	 *	@param	cache2				true to use second level cache.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public static void init( Class[] persistentClasses , boolean cache2 )
		throws PersistenceException
	{
		init( null , null , null , null , persistentClasses , cache2 );
	}

	/**	Initializes Hibernate using the default configuration file.
	 *
	 *	@param	persistentClasses	Array of persistent classes.  Should not be
	 *								null.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public static void init( Class[] persistentClasses )
		throws PersistenceException
	{
		init( null , null , null , null , persistentClasses , false );
	}

	/**	Creates a new persistence manager.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public HibernatePersistenceManager()
		throws PersistenceException
	{
		try
		{
			session	= sessionFactory.openSession();

		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Get the session from this persistence manager.
	 *
	 *	@return		The session.
	 */

	public Session getSession()
	{
		return session;
	}

	/**	Clear the first-level cache.
	 */

	public void clear()
	{
		session.clear();
	}

	/**	Clear the first-level cache.
	 */

	public static void doClear()
	{
		try
		{
			HibernatePersistenceManager pm	= getHPM();

			if ( pm != null )
			{
				pm.clear();
			}
    	}
    	catch ( Exception e )
    	{
    							//	Eat the exception.

			if ( stackTracesEnabled ) e.printStackTrace();
    	}
	}

	/**	Gets the JDBC connection.
	 *
	 *	@return 	The JDBC connection.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public Connection getConnection()
		throws PersistenceException
	{
		try
		{
			return sessionFactory.getSessionFactoryOptions().getServiceRegistry()
								 .getService(ConnectionProvider.class)
								 .getConnection();
		}
		catch ( SQLException e )
		{
			throw new PersistenceException( e );
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Check if an object is loaded in the current session.
	 *
	 *	@param	obj		The object to check.
	 *
	 *	@return			true if the object is loaded in the current session,
	 *					false otherwise.
	 */

	public boolean contains( Object obj )
	{
		return session.contains( obj );
	}

	/**	Check if an object is loaded in the current session.
	 *
	 *	@param	obj		The object to check.
	 *
	 *	@return			true if the object is loaded in the current session,
	 *					false otherwise.
	 */

	public static boolean doContains( Object obj )
	{
		boolean result	= false;

		try
		{
			HibernatePersistenceManager pm	= getHPM();

			if ( pm != null )
			{
				result	= pm.contains( obj );
			}
    	}
    	catch ( Exception e )
    	{
    							//	Eat the exception.

			if ( stackTracesEnabled ) e.printStackTrace();
    	}

    	return result;
	}

	/**	Refresh an object.
	 *
	 *	@param	obj		The object to refresh.
	 */

	public void refresh( Object obj )
	{
		session.refresh( obj );
	}

	/**	Refresh an object.
	 *
	 *	@param	obj		The object to refresh.
	 */

	public static void doRefresh( Object obj )
	{
		try
		{
			HibernatePersistenceManager pm	= getHPM();

			if ( pm != null )
			{
				pm.refresh( obj );
			}
    	}
    	catch ( Exception e )
    	{
    							//	Eat the exception.

			if ( stackTracesEnabled ) e.printStackTrace();
    	}
	}

	/**	Clear all objects of the specified class from the second-level cache.
	 *
	 *	@param	evictionClass	The persistent class whose cached objects
	 *							should be evicted.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void evict( Class evictionClass )
		throws PersistenceException
	{
		try
		{
			session.evict( evictionClass.getName() );
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Clear all objects of the specified class from the second-level cache.
	 *
	 *	@param	evictionClass	The persistent class whose cached objects
	 *							should be evicted.
	 */

	public static void doEvict( Class evictionClass )
	{
		try
		{
			HibernatePersistenceManager pm	= getHPM();

			if ( pm != null )
			{
				pm.evict( evictionClass );
			}
    	}
    	catch ( Exception e )
    	{
    							//	Eat the exception.

			if ( stackTracesEnabled ) e.printStackTrace();
    	}
	}

	/**	Evict an object from the session cache.
	 *
	 *	@param	obj		The object to evict.
	 *
	 *	@throws			PersistenceException	for persistence layer error
	 */

	public void evict( Object obj )
		throws PersistenceException
	{
		try
		{
			session.evict( obj );
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Evict an object from the session cache.
	 *
	 *	@param	obj		The object to evict.
	 */

	public static void doEvict( Object obj )
	{
		try
		{
			HibernatePersistenceManager pm	= getHPM();

			if ( pm != null )
			{
				pm.evict( obj );
			}
    	}
    	catch ( Exception e )
    	{
    							//	Eat the exception.

			if ( stackTracesEnabled ) e.printStackTrace();
    	}
	}

	/**	Closes the persistence manager.
	 *
	 *	<p>You should close persistence managers when you are finished with
	 *	them. Persistence managers may not be reused after they have been
	 *	closed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void close()
		throws PersistenceException
	{
		try
		{
			session.close();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Close a persistence manager.  Static convenience method.
	 *
	 *	@param	pm	The persistence manager to close.
	 *
	 *	<p>
	 *	Any errors are thrown away.
	 *	</p>
	 */

	public static void closePM( HibernatePersistenceManager pm )
	{
		if ( pm != null )
		{
			try
			{
				pm.close();
				pm	= null;

				threadPM.set( pm );
			}
			catch ( Exception e )
			{
			}
		}
	}

	/**	Begins a transaction if one is not already in progress.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void begin()
		throws PersistenceException
	{
		try
		{
			if ( t != null ) return;

			t	= session.beginTransaction();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Commits a transaction if one is in progress.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void commit()
		throws PersistenceException
	{
		try
		{
			if ( t == null ) return;

			t.commit();

			t = null;
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Flushes current transaction state.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void flush()
		throws PersistenceException
	{
		try
		{
			session.flush();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Rolls back a transaction if one is in progress.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void rollback()
		throws PersistenceException
	{
		try
		{
			if ( t == null ) return;

			t.rollback();

			t	= null;
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Saves an object (makes it persistent).
	 *
	 *	<p>If a transaction is not already in progress, a new transaction
	 *	is started and commited for the operation.
	 *
	 *	@param	obj		The object.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void save( Object obj )
		throws PersistenceException
	{
		if ( obj == null ) return;

		try
		{
			boolean active = ( t != null );

			if ( !active ) begin();

			session.save( obj );

			if ( !active ) commit();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Saves a collection of objects.
	 *
	 *	<p>If a transaction is not already in progress, a new transaction
	 *	is started and committed for the operation.</p>
	 *
	 *	@param	collection	Collection of objects.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void save( Collection collection )
		throws PersistenceException
	{
		if ( collection == null ) return;

		try
		{
			boolean active = ( t != null );

			if ( !active ) begin();

			int count	= 0;

			for ( Iterator it = collection.iterator() ; it.hasNext() ; )
			{
				session.save( it.next() );
			}

			if ( !active ) commit();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Saves an object.
	 *
	 *	<p>If a transaction is not already in progress, a new transaction
	 *	is started and committed for the operation.</p>
	 *
	 *	@param	obj		Object to save.
	 *
	 *	@return			true if objects saved, false otherwise.
	 */

	public static boolean doSave( Object obj )
	{
		boolean result	= false;

		if ( obj != null )
		{
			try
			{
				HibernatePersistenceManager pm	= getHPM();

				if ( pm != null )
				{
					pm.save( obj );

					result	= true;
				}
			}
			catch ( PersistenceException e )
			{
    							//	Eat the exception and return false.

				if ( stackTracesEnabled ) e.printStackTrace();
			}
		}

		return result;
	}

	/**	Saves a collection of objects.
	 *
	 *	<p>If a transaction is not already in progress, a new transaction
	 *	is started and committed for the operation.</p>
	 *
	 *	@param	collection	Collection of objects.
	 *
	 *	@return		true if all objects saved, false otherwise.
	 */

	public static boolean doSave( Collection collection )
	{
		boolean result	= false;

		if ( collection != null )
		{
			try
			{
				HibernatePersistenceManager pm	= getHPM();

				if ( pm != null )
				{
					pm.save( collection );

					result	= true;
				}
			}
			catch ( PersistenceException e )
			{
    							//	Eat the exception and return false.

				if ( stackTracesEnabled ) e.printStackTrace();
			}
		}

		return result;
	}

	/**	Deletes an object.
	 *
	 *	<p>If a transaction is not already in progress, a new transaction
	 *	is started and commited for the operation.</p>
	 *
	 *	@param	obj		The object.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void delete( Object obj )
		throws PersistenceException
	{
		if ( obj == null ) return;

		try
		{
			boolean active = ( t != null );

			if ( !active ) begin();

			session.delete( obj );

			if ( !active ) commit();

		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Deletes a collection of objects.
	 *
	 *	<p>If a transaction is not already in progress, a new transaction
	 *	is started and commited for the operation.</p>
	 *
	 *	@param	collection	Collection of objects.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void delete( Collection collection )
		throws PersistenceException
	{
		if ( collection == null ) return;

		try
		{
			boolean active	= ( t != null );

			if ( !active ) begin();

			for ( Iterator it = collection.iterator() ; it.hasNext(); )
			{
				session.delete( it.next() );
			}

			if ( !active ) commit();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Deletes an object.
	 *
	 *	<p>If a transaction is not already in progress, a new transaction
	 *	is started and committed for the operation.</p>
	 *
	 *	@param	obj			Object to delete.
	 *
	 *	@return				true if object deleted, false otherwise.
	 */

	public static boolean doDelete( Object obj )
	{
		boolean result	= false;

		if ( obj != null )
		{
			try
			{
				HibernatePersistenceManager pm	= getHPM();

				if ( pm != null )
				{
					pm.delete( obj );

					result	= true;
				}
			}
			catch ( PersistenceException e )
			{
    							//	Eat the exception and return false.

				if ( stackTracesEnabled ) e.printStackTrace();
			}
		}

		return result;
	}

	/**	Deletes a collection of objects.
	 *
	 *	<p>If a transaction is not already in progress, a new transaction
	 *	is started and committed for the operation.</p>
	 *
	 *	@param	collection	Collection of objects to delete.
	 *
	 *	@return				true if all objects deleted, false otherwise.
	 */

	public static boolean doDelete( Collection collection )
	{
		boolean result	= false;

		if ( collection != null )
		{
			try
			{
				HibernatePersistenceManager pm	= getHPM();

				if ( pm != null )
				{
					pm.delete( collection );

					result	= true;
				}
			}
			catch ( PersistenceException e )
			{
    							//	Eat the exception and return false.

				if ( stackTracesEnabled ) e.printStackTrace();
			}
		}

		return result;
	}

	/**	Get the current thread's persistence manager.
	 *
	 *	@return		The current thread's persistence manager.
	 *
	 *	<p>
	 *	A new persistence manager for the current thread is created if
	 *	it does not yet exist.
	 *	</p>
	 *	@throws	PersistenceException	error in persistence call
	 */

	public static HibernatePersistenceManager getHPM()
		throws PersistenceException
	{
		HibernatePersistenceManager pm	=
			(HibernatePersistenceManager)threadPM.get();

		try
		{
			if ( pm == null )
			{
				pm	= new HibernatePersistenceManager();

				threadPM.set( pm );
			}
		}
		catch ( Exception e )
		{
			throw new PersistenceException( e );
		}

		return pm;
	}

	/**	Loads a persistent object by class and id.
	 *
	 *	<p>Note that every model object has a unique persistent id of type
	 *	Long. These id's are assigned by Hibernate and MySQL. The combination
	 *	of a persistent object's Java type (class) and its id uniquely
	 *	identifies the object.  The returned object is never supposed to be
	 *	a proxy object.</p>
	 *
	 *	@param	type	The object's class.
	 *
	 *	@param	id		The object's id.
	 *
	 *	@return			The loaded object.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public Object get( Class type , Long id )
		throws PersistenceException
	{
		if ( type == null ) return null;

		try
		{
			return session.get( type , id );
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Loads a persistent object by class and id.	Static convenience method.
	 *
	 *	@param	type	The object's class.
	 *
	 *	@param	id		The object's id.
	 *
	 *	@return			The loaded object.
	 */

	public static Object doGet( Class type , Long id )
	{
		Object result			= null;

		if ( ( type == null ) || ( id == null ) ) return result;

		try
		{
								//	Get current persistence manager.

			HibernatePersistenceManager pm	= getHPM();

								//	Get the requested object.

			if ( pm != null ) result = pm.get( type , id );
		}
		catch ( PersistenceException e )
		{
    							//	Eat the exception and return
    							//	a null object.

			if ( stackTracesEnabled ) e.printStackTrace();
		}

		return result;
	}

	/**	Loads a persistent object by class and id.
	 *
	 *	<p>Note that every model object has a unique persistent id of type
	 *	Long. These id's are assigned by Hibernate and MySQL. The combination
	 *	of a persistent object's Java type (class) and its id uniquely
	 *	identifies the object.  The returned object may be a proxy object.</p>
	 *
	 *	@param	type	The object's class.
	 *
	 *	@param	id		The object's id.
	 *
	 *	@return			The loaded object.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public Object load( Class type , Long id )
		throws PersistenceException
	{
		if ( type == null ) return null;

		try
		{
			return session.load( type , id );
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Loads a persistent object by class and id.	Static convenience method.
	 *
	 *	@param	type	The object's class.
	 *
	 *	@param	id		The object's id.
	 *
	 *	@return			The loaded object.
	 */

	public static Object doLoad( Class type , Long id )
	{
		Object result			= null;

		if ( ( type == null ) || ( id == null ) ) return result;

		try
		{
								//	Get current persistence manager.

			HibernatePersistenceManager pm	= getHPM();

								//	Get the object.

			if ( pm != null ) result = pm.load( type , id );
		}
		catch ( PersistenceException e )
		{
    							//	Eat the exception and return
    							//	a null object.

			if ( stackTracesEnabled ) e.printStackTrace();
		}

		return result;
	}

	/**	Updates an object.
	 *
	 *	@param	obj		The persistent object to update on the database.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void update( Object obj )
		throws PersistenceException
	{
		if ( obj == null ) return;

		try
		{
								//	Start transaction if not already started.

			boolean active = t != null;

			if ( !active ) begin();

								//	Update the object.

			session.update( obj );

								//	Finish transaction if we started it.

			if ( !active ) commit();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Updates collection of objects.
	 *
	 *	@param	collection		The collection containing persistence objects
	 *							to update on the database.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public void update( Collection collection )
		throws PersistenceException
	{
		if ( collection == null ) return;

		try
		{
								//	Start transaction if not already started.

			boolean active = t != null;

			if ( !active ) begin();

								//	Update the objects in the collection.

			for	(	Iterator iterator = collection.iterator() ;
					iterator.hasNext() ; )
			{
				session.update( iterator.next() );
			}
								//	Finish transaction if we started it.

			if ( !active ) commit();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}
	}

	/**	Updates an object.
	 *
	 *	@param	obj		The persistent object to update on the database.
	 *
	 *	@return			true if object updated, false otherwise.
	 */

	public static boolean doUpdate( Object obj )
	{
		boolean result	= false;

		if ( obj == null ) return result;

		try
		{
								//	Get current persistence manager.

			HibernatePersistenceManager pm	= getHPM();

								//	Get the list of query results.

			if ( pm != null ) pm.update( obj );

			result	= true;
		}
		catch ( PersistenceException e )
		{
    							//	Eat the exception and return false
    							//	to indicate the update failed.

			if ( stackTracesEnabled ) e.printStackTrace();
		}

		return result;
	}

	/**	Updates a collection.
	 *
	 *	@param	collection		The collection containing persistence objects
	 *							to update on the database.
	 *
	 *	@return					true if collection updated, false otherwise.
	 */

	public static boolean doUpdate( Collection collection )
	{
		boolean result	= false;

		if ( collection == null ) return result;

		try
		{
								//	Get current persistence manager.

			HibernatePersistenceManager pm	= getHPM();

								//	Get the list of query results.

			if ( pm != null ) pm.update( collection );

			result	= true;
		}
		catch ( PersistenceException e )
		{
    							//	Eat the exception and return false
    							//	to indicate the update failed.

			if ( stackTracesEnabled ) e.printStackTrace();
		}

		return result;
	}

	/**	Delete objects via query.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *
	 *	@return					Count of objects deleted.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public int deleteViaQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues
	)
		throws PersistenceException
	{
		int result	= 0;

		try
		{
								//	Create query.

			Query query	= session.createQuery( queryString );

								//	Add parameter names and values.

			for ( int i = 0 ; i < paramNames.length ; i++ )
			{
				Object paramValue	= paramValues[ i ];

								//	Check for Collection

				if ( paramValue instanceof Collection )
				{
					query.setParameterList(
						paramNames[ i ] ,
						(Collection)paramValue );
				}
								//	Check for Array
								//	$$$PIB Doesn't work, use
								//	Arrays.asList( array ) in caller.

				else if ( paramValue instanceof java.lang.reflect.Array )
				{
					query.setParameterList(
						paramNames[ i ] ,
						(Object[])paramValue );
				}
								//	Otherwise assume an entity reference.
				else
				{
					query.setParameter( paramNames[ i ] , paramValue );
				}
			}
								//	Get the count of results.

			result	= query.executeUpdate();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}

		return result;
	}

	/**	Delete objects via query.
	 *
	 *	@param	queryString		The query string.
	 *
	 *	@return					Count of objects deleted.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public int deleteViaQuery( String queryString )
		throws PersistenceException
	{
		int result	= 0;

		try
		{
								//	Create query.

			Query query	= session.createQuery( queryString );

								//	Get the list of query results.

			result	= query.executeUpdate();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}

		return result;
	}

	/**	Delete objects via SQL query.
	 *
	 *	@param	queryString		The query string.
	 *
	 *	@return					Count of objects deleted.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 *
	 *	<p>
	 *	This method provides for executing a standard SQL "delete from" query.
	 *	Until the Hibernate parser handles all queries and batch deletes
	 *	correctly, this is the fastest way to perform batch deletes.
	 *	</p>
	 */

	public int deleteViaSQL( String queryString )
		throws PersistenceException
	{
		int result	= 0;

		try
		{
								//	Get JDBC connection.

			Statement statement	=
				getConnection().createStatement();

								//	Perform the update/delete query.

			result	= statement.executeUpdate( queryString );
			statement.close();
		}
		catch ( Exception e )
		{
			throw new PersistenceException( e );
		}

		return result;
	}

	/**	Set query parameters and values.
	 *
	 *	@param	query			The query for which to set parameters and values.
	 *	@param	paramNames		The query parameter names.
	 *	@param	paramValues		The parameter values.
	 *	@param	cacheQuery		True to cache the query.
	 *	@param	singleResult	true if query will return single result.
	 *	@param	maxResults		Maximum number of results to return.
	 *							0 = no limit.
	 */

	public void setQueryParams
	(
		Query query ,
		String[] paramNames ,
		Object[] paramValues ,
		boolean cacheQuery ,
		boolean singleResult ,
		int maxResults
	)
	{
								//	Add parameter names and values.

		if ( ( paramNames != null ) && ( paramValues != null ) )
		{
			for ( int i = 0 ; i < paramNames.length ; i++ )
			{
				Object paramValue	= paramValues[ i ];

								//	Check for Collection

				if ( paramValue instanceof Collection )
				{
					query.setParameterList(
						paramNames[ i ] ,
						(Collection)paramValue );
				}
								//	Check for Array
								//	$$$PIB Doesn't work, use
								//	Arrays.asList( array ) in caller.

				else if ( paramValue instanceof java.lang.reflect.Array )
				{
					query.setParameterList(
						paramNames[ i ] ,
						(Object[])paramValue );
				}
								//	Otherwise assume an entity reference.
				else
				{
					query.setParameter( paramNames[ i ] , paramValue );
				}
			}
		}
								//	Set maximum number of results.

		if ( maxResults > 0 )
		{
			query.setMaxResults( maxResults );
		}
								//	Enable cache if requested.

		query.setCacheable( cacheQuery );
	}

	/**	Perform query.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *	@param	cacheQuery		True to cache the query.
	 *	@param	maxResults		Maximum number of results to return.
	 *							0 = no limit.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 *
	 *	<p>
	 *	Any parameter that is not of type String, Integer, Long, Boolean,
	 *	or Collection is assumed to be an entity reference.
	 *	</p>
	 */

	public List query
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues ,
		boolean cacheQuery ,
		int maxResults
	)
		throws PersistenceException
	{
		List result	= null;

		try
		{
								//	Create query.

			Query query	= session.createQuery( queryString );

								//	Set query parameters.
			setQueryParams
			(
				query ,
				paramNames ,
				paramValues ,
				cacheQuery ,
				false ,
				maxResults
			);
								//	Get the list of query results.

			result	= query.list();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}

		return result;
	}

	/**	Perform query.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *	@param	cacheQuery		True to cache the query.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 *
	 *	<p>
	 *	Any parameter that is not of type String, Integer, Long, Boolean,
	 *	or Collection is assumed to be an entity reference.
	 *	</p>
	 */

	public List query
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues ,
		boolean cacheQuery
	)
		throws PersistenceException
	{
		return query(
			queryString , paramNames , paramValues , cacheQuery , 0 );
	}

	/**	Perform query.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 *
	 *	<p>
	 *	Any parameter that is not of type String, Integer, or Long
	 *	is assumed to be an entity reference.
	 *	</p>
	 */

	public List query
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues
	)
		throws PersistenceException
	{
		return query( queryString , paramNames , paramValues , false );
	}

	/**	Perform query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *	@param	cacheQuery		True to cache query.
	 *	@param	maxResults		Maximum number of result rows to retrieve.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static List doQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues ,
		boolean cacheQuery ,
		int maxResults
	)
	{
								//	Assume no query results.
		List result	= null;
								//	Get current persistence manager.

		try
		{
			HibernatePersistenceManager pm	= getHPM();

								//	Get the list of query results.

			if ( pm != null )
			{
				result	=
					pm.query
					(
						queryString ,
						paramNames ,
						paramValues ,
						cacheQuery ,
						maxResults
					);
			}
		}
		catch ( PersistenceException e )
		{
    							//	Eat the exception and return
    							//	a null query results list.

			if ( stackTracesEnabled ) e.printStackTrace();
		}

		return result;
	}

	/**	Perform query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *	@param	cacheQuery		True to cache query.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static List doQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues ,
		boolean cacheQuery
	)
	{
		return doQuery(
			queryString , paramNames , paramValues , cacheQuery , 0 );
	}

	/**	Perform query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static List doQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues
	)
	{
		return doQuery( queryString , paramNames , paramValues , false , 0 );
	}

	/**	Perform query.
	 *
	 *	@param	queryString		The query string.
	 *	@param	cacheQuery		True to cache query.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public List query( String queryString , boolean cacheQuery )
		throws PersistenceException
	{
		List result	= null;

		try
		{
								//	Create query.
			Query query	= session.createQuery( queryString );

								//	Enable cache if requested.

			query.setCacheable( cacheQuery );

								//	Get the list of query results.

			result	= query.list();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}

		return result;
	}

	/**	Perform query.
	 *
	 *	@param	queryString		The query string.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public List query( String queryString )
		throws PersistenceException
	{
		return query( queryString , false );
	}

	/**	Perform query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *	@param	cacheQuery		True to cache the query results.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static List doQuery
	(
		String queryString ,
		boolean cacheQuery
	)
	{
								//	Assume no query results.
		List result	= null;

								//	Get current persistence manager.
		try
		{
			HibernatePersistenceManager pm	= getHPM();

								//	Get the list of query results.

			if ( pm != null )
			{
				result	= pm.query( queryString , cacheQuery );
			}
    	}
    	catch ( Exception e )
    	{
    							//	Eat the exception and return
    							//	a null query results list.

			if ( stackTracesEnabled ) e.printStackTrace();
    	}

		return result;
	}

	/**	Perform query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *	@param	maxResults		Maximum number of results.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static List doQuery( String queryString , int maxResults )
	{
		return doQuery( queryString , null , null , false , maxResults );
	}

	/**	Perform query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static List doQuery( String queryString )
	{
		return doQuery( queryString , false );
	}

	/**	Perform count query.
	 *
	 *	@param	queryString		The query string.
	 *							A "select count(*) " phrase is added to
	 *							the front, so DO NOT specify this in the
	 *							input query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *
	 *	@return					Count returned by query.  0 if the query fails.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public int countQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues
	)
		throws PersistenceException
	{
		int result	= 0;

		try
		{
								//	Create query.

			Query query	= session.createQuery(
				"select count(*) " + queryString );

								//	Set query parameters.
			setQueryParams
			(
				query ,
				paramNames ,
				paramValues ,
				false ,
				true ,
				0
			);
								//	Get the query result.

			Long queryResult	= (Long)query.uniqueResult();

			if ( queryResult != null )
			{
				result	= (int)queryResult.longValue();
			}
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}

		return result;
	}

	/**	Perform count query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *
	 *	@return					Count returned by query.  0 if the query fails.
	 */

	public static int doCountQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues
	)
	{
								//	Assume no query results.
		int result	= 0;

								//	Get current persistence manager.
		try
		{
			HibernatePersistenceManager pm	= getHPM();

								//	Get the query result.

			if ( pm != null )
			{
				result	=
					pm.countQuery( queryString , paramNames , paramValues  );
			}
    	}
    	catch ( Exception e )
    	{
    							//	Eat the exception and return
    							//	a null query results list.

			if ( stackTracesEnabled ) e.printStackTrace();
    	}

		return result;
	}

	/**	Insert data via SQL.
	 *
	 *	@param	insertString	The SQL insert string.
	 *
	 *	@return					Count of objects inserted.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 *
	 *	<p>
	 *	This method provides for executing a standard SQL "insert" query.
	 *	This is much faster than using standard Hibernate facilities for large
	 *	batches of inserts.
	 *	</p>
	 */

	public int insertViaSQL( String insertString )
		throws PersistenceException
	{
		int result	= 0;

		try
		{
								//	Get JDBC connection.

			Statement statement	=
				getConnection().createStatement();

								//	Perform the insert.

			result	= statement.executeUpdate( insertString );
			statement.close();
		}
		catch ( Exception e )
		{
			throw new PersistenceException( e );
		}

		return result;
	}

	/**	Insert data via SQL.
	 *
	 *	@param	insertString	The SQL insert string.
	 *
	 *	@return					Count of objects inserted.
	 */

	public static int doInsertViaSQL( String insertString )
	{
		int result	= 0;

		try
		{
								//	Ger persistence manager.

			HibernatePersistenceManager pm	= getHPM();

								//	Perform the insert/update.

			if ( pm != null )
			{
				result	= pm.insertViaSQL( insertString );
			}
		}
		catch ( Exception e )
		{
		}

		return result;
	}

	/**	Perform scrollable query.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *	@param	cacheQuery		True to cache the query.
	 *	@param	maxResults		Maximum number of results to return.
	 *							0 = no limit.
	 *
	 *	@return					Scrollable query result, or
	 *							null if query failed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 *
	 *	<p>
	 *	Any parameter that is not of type String, Integer, Long, Boolean,
	 *	or Collection is assumed to be an entity reference.
	 *	</p>
	 */

	public ScrollableResults scrollableQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues ,
		boolean cacheQuery ,
		int maxResults
	)
		throws PersistenceException
	{
		ScrollableResults result	= null;

		try
		{
								//	Create query.

			Query query	= session.createQuery( queryString );

								//	Set query parameters.
			setQueryParams
			(
				query ,
				paramNames ,
				paramValues ,
				cacheQuery ,
				false ,
				maxResults
			);
								//	Get the list of query results.

			result	= query.scroll();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}

		return result;
	}

	/**	Perform scrollable query.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *	@param	cacheQuery		True to cache the query.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 *
	 *	<p>
	 *	Any parameter that is not of type String, Integer, Long, Boolean,
	 *	or Collection is assumed to be an entity reference.
	 *	</p>
	 */

	public ScrollableResults scrollableQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues ,
		boolean cacheQuery
	)
		throws PersistenceException
	{
		return scrollableQuery(
			queryString , paramNames , paramValues , cacheQuery , 0 );
	}

	/**	Perform scrollable query.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 *
	 *	<p>
	 *	Any parameter that is not of type String, Integer, or Long
	 *	is assumed to be an entity reference.
	 *	</p>
	 */

	public ScrollableResults scrollableQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues
	)
		throws PersistenceException
	{
		return scrollableQuery(
			queryString , paramNames , paramValues , false );
	}

	/**	Perform scrollable query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *	@param	cacheQuery		True to cache query.
	 *	@param	maxResults		Maximum number of result rows to retrieve.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static ScrollableResults doScrollableQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues ,
		boolean cacheQuery ,
		int maxResults
	)
	{
								//	Assume no query results.
		ScrollableResults result	= null;
								//	Get current persistence manager.

		try
		{
			HibernatePersistenceManager pm	= getHPM();

								//	Get the list of query results.

			if ( pm != null )
			{
				result	=
					pm.scrollableQuery
					(
						queryString ,
						paramNames ,
						paramValues ,
						cacheQuery ,
						maxResults
					);
			}
		}
		catch ( PersistenceException e )
		{
    							//	Eat the exception and return
    							//	a null query results list.

			if ( stackTracesEnabled ) e.printStackTrace();
		}

		return result;
	}

	/**	Perform scrollable query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *	@param	cacheQuery		True to cache query.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static ScrollableResults doScrollableQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues ,
		boolean cacheQuery
	)
	{
		return doScrollableQuery(
			queryString , paramNames , paramValues , cacheQuery , 0 );
	}

	/**	Perform scrollable query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *	@param	paramNames		Parameter names used in the query.
	 *	@param	paramValues		Parameter values for each paramName.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static ScrollableResults doScrollableQuery
	(
		String queryString ,
		String[] paramNames ,
		Object[] paramValues
	)
	{
		return doScrollableQuery(
			queryString , paramNames , paramValues , false , 0 );
	}

	/**	Perform scrollable query.
	 *
	 *	@param	queryString		The query string.
	 *	@param	cacheQuery		True to cache query.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public ScrollableResults scrollableQuery
	(	String queryString ,
		boolean cacheQuery
	)
		throws PersistenceException
	{
		ScrollableResults result	= null;

		try
		{
								//	Create query.

			Query query	= session.createQuery( queryString );

								//	Enable cache if requested.

			query.setCacheable( cacheQuery );

								//	Get the list of query results.

			result	= query.scroll();
		}
		catch ( HibernateException e )
		{
			throw new PersistenceException( e );
		}

		return result;
	}

	/**	Perform scrollable query.
	 *
	 *	@param	queryString		The query string.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public ScrollableResults scrollableQuery( String queryString )
		throws PersistenceException
	{
		return scrollableQuery( queryString , false );
	}

	/**	Perform scrollable query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *	@param	cacheQuery		True to cache the query results.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static ScrollableResults doScrollableQuery
	(
		String queryString ,
		boolean cacheQuery
	)
	{
								//	Assume no query results.

		ScrollableResults result	= null;

								//	Get current persistence manager.
		try
		{
			HibernatePersistenceManager pm	= getHPM();

								//	Get the list of query results.

			if ( pm != null )
			{
				result	= pm.scrollableQuery( queryString , cacheQuery );
			}
    	}
    	catch ( Exception e )
    	{
    							//	Eat the exception and return
    							//	a null query results list.

			if ( stackTracesEnabled ) e.printStackTrace();
    	}

		return result;
	}

	/**	Perform scrollable query.	Static convenience method.
	 *
	 *	@param	queryString		The query string.
	 *
	 *	@return					List of objects resulting from query, or
	 *							null if query failed.
	 */

	public static ScrollableResults doScrollableQuery( String queryString )
	{
		return doScrollableQuery( queryString , false );
	}

	/**	Enable or disable stack trace output for static methods.
	 *
	 *	@param	enableTraces	true to enable tracing.
	 */

	public static void enableStackTraces( boolean enableTraces )
	{
		stackTracesEnabled	= enableTraces;
	}

	/**	Return the JDBC batch size.
	 *
	 *	@return		The JDBC batch size.
	 */

	public static int getBatchSize()
	{
		return JDBC_BATCH_SIZE;
	}

	/**	Gets the connection provider.
	 *
	 *	@return		The connection provider.
	 */

	public ConnectionProvider getConnectionProvider()
	{
		return ((SessionFactoryImplementor)sessionFactory).getServiceRegistry().getService(ConnectionProvider.class);
	}

	/**	Performs batch inserts using prepared MySQL insert statements.
	 *
	 *	@param	insertStatements	String array of MySQL insert statements.
	 *
	 *	@return	count of inserts performed.
	 *
	 *	@throws	PersistenceException	error in persistence call
	 */

	public int performBatchInserts( String[] insertStatements )
		throws PersistenceException
	{
		int result	= 0;

		try
		{
			begin();

			for ( int i = 0 ; i < insertStatements.length ; i++ )
			{
				result	+=
					insertViaSQL( insertStatements[ i ] );
			}

			commit();
		}
		catch ( HibernateException e )
		{
			try
			{
				rollback();
			}
			catch ( Exception ignored )
			{
			}

			throw new PersistenceException( e );
		}

		return result;
	}
}

/*
 * <p>
 * Copyright &copy; 2004-2011 Northwestern University.
 * </p>
 * <p>
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * </p>
 * <p>
 * This program is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU General Public License for more
 * details.
 * </p>
 * <p>
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the Free
 * Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA.
 * </p>
 */

